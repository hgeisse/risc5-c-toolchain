
RISC5 Architecture
==================

0. Overview
-----------

This document is based on Niklaus Wirth's descriptions of his RISC processor
[1,2,3,4]. We try to stay compatible with the processor described therein,
but take the liberty to specify some aspects of the system in greater detail.
Moreover, we add a very few features that are missing in the original design
(16-bit memory access, multiple interrupt sources, nested interrupts).

From the viewpoint of the programmer and the compiler designer the computer
consists of registers, an arithmetic unit, a control unit, and the main
memory. The set of registers comprises 16 general purpose registers R0 - R15,
as well as 4 special registers (ID, H, X, PSW), with 32 bits each. The ID
register holds details about the implementation and is read-only. The H
register is used as the high word for results when multiplying, and as the
remainder when dividing. The processor status word PSW records the properties
of the results of arithmetic operations (the "flag bits"), which can be used
to alter the program flow. It also holds interrupt control information. The
X register is used to record the program counter and the flag bits when an
interrupt is acknowledged. The control unit consists of the program counter
PC, holding the address of the instruction to be fetched next, and facilities
to accomodate interrupts. The main memory is byte-addressed and consists of
32-bit words in little-endian byte order. All word accesses (instruction
fetch, data load/store) must be word-aligned (i.e., on addresses which are
divisible by 4), all half-word accesses must be on even addresses.

There are four types of instructions and thus four instruction formats.
Register instructions operate either on registers only (format F0), or on
a register and a constant embedded in the current instruction (format F1).
They feed data through the arithmetic/logic unit. Memory instructions
(format F2) load and store data from and to memory, either as a single
byte, as two bytes together (half-word), or as 4 bytes together (word).
Device I/O is memory-mapped, i.e., the addresses of all I/O devices are
mapped into the general address space of the computer and thus are accessible
using memory instructions (although only word transfers are supported
with I/O devices). Branch instructions (format F3) affect the program
counter. They optionally record the linear next instruction address in
order to realize subroutine calls and returns.

The type of an instruction is encoded in its topmost nibble (bits 31..28,
"pquv"). The "pq" bits determine the format (F0..F3), the "uv" bits are
used as modifiers.


1. Register Instructions
------------------------

Register instructions assign the result of an operation to the
destination register R.a. The first operand is the register R.b.
The second operand n is either register R.c (format F0) or is the
constant imm taken from the current instruction (format F1). The
modifier bits uv are both zero; exceptions are described below.

        4      4      4      4             12            4
     +------+------+------+------+------+------+------+------+
F0:  | 00uv |  a   |  b   |  op  |         --         |  c   |
     +------+------+------+------+------+------+------+------+

        4      4      4      4             16
     +------+------+------+------+------+------+------+------+
F1:  | 01uv |  a   |  b   |  op  |         imm               |
     +------+------+------+------+------+------+------+------+

op     instr        effect             explanation
-----------------------------------------------------------------------
0000   MOV a,n      R.a := n           data transfer
0001   LSL a,b,n    R.a := R.b <- n    logical shift left by n bits
0010   ASR a,b,n    R.a := R.b -> n    arithmetic shift right by n bits
0011   ROR a,b,n    R.a := R.b rot n   rotate right by n bits
0100   AND a,b,n    R.a := R.b & n     bitwise AND
0101   ANN a,b,n    R.a := R.b & ~n    bitwise AND NOT
0110   IOR a,b,n    R.a := R.b or n    bitwise inclusive OR
0111   XOR a,b,n    R.a := R.b xor n   bitwise exclusive OR
1000   ADD a,b,n    R.a := R.b + n     integer addition
1001   SUB a,b,n    R.a := R.b - n     integer subtraction
1010   MUL a,b,n    R.a := R.b * n     integer multiplication (1)
1011   DIV a,b,n    R.a := R.b / n     integer division (2)
1100   FAD a,b,n    R.a := R.b + R.c   floating-point addition
1101   FSB a,b,n    R.a := R.b - R.c   floating-point subtraction
1110   FML a,b,n    R.a := R.b * R.c   floating-point multiplication
1111   FDV a,b,n    R.a := R.b / R.c   floating-point division (3)

Remarks:
(1) The upper 32 bits of the product are deposited in register H.
(2) The remainder is deposited in register H. Integer division is
    defined as "Euclidean division" with the following properties:
    Let q = b / c and r = b mod c. Then b = q * c + r, 0 <= r < abs(c).
    Quotient q as well as remainder r are undefined if c = 0. They
    are also undefined if b = most negative number and c = -1.
(3) The result is undefined if R.c = 0.

Immediate values are extended to 32 bits with 16 v-bits to the left.
Apart from R.a these instructions also affect the flag registers N
(negative) and Z (zero). The ADD and SUB instructions also affect
the flags C (carry with ADD, borrow with SUB) and V (overflow).


2. Memory Instructions
----------------------

        4      4      4                    20
     +------+------+------+------+------+------+------+------+
F2:  | 10uv |  a   |  b   |                off               |
     +------+------+------+------+------+------+------+------+

uv   instr         effect                  explanation
-----------------------------------------------------------------------
00   LDW a,b,off   R.a := mem[R.b + off]   word from mem, LSB(off) = 0
00   LDH a,b,off   R.a := mem[R.b + off]   half from mem, LSB(off) = 1
01   LDB a,b,off   R.a := mem[R.b + off]   byte from mem
10   STW a,b,off   mem[R.b + off] := R.a   word from R.a, LSB(off) = 0
10   STH a,b,off   mem[R.b + off] := R.a   half from R.a, LSB(off) = 1
11   STB a,b,off   mem[R.b + off] := R.a   byte from R.a

The offset "off" is interpreted as a signed 20-bit number in two's
complement representation. The LSB of the offset in an LDW or STW
instruction distinguishes a word from a half-word memory access.
This bit is taken to be zero before the actual address is computed.

Half-words (and bytes) are zero-extended when read from memory and
written to a register. They are read from the 16 (or 8, for bytes)
LSBs of the register when written to memory.


3. Branch Instructions
----------------------

All branch instructions are formally dependent on a condition
(but there is an "always true" condition). The branch instructions
optionally store the current PC value ("link address" for calls).
The branch target either is taken from a register or is computed
from the current PC and an offset contained in the instruction.

        4      4             16                   4      4
     +------+------+------+------+------+------+------+------+
F3:  | 110v | code |         --                | 0000 |  c   |
     +------+------+------+------+------+------+------+------+

Here u = 0, so the destination address is taken from register R.c.

        4      4             24
     +------+------+------+------+------+------+------+------+
F3:  | 111v | code |         off                             |
     +------+------+------+------+------+------+------+------+

Here u = 1, so the destination address is PC + (1 + off) * 4.
The offset is interpreted as a signed 24-bit number in two's
complement representation.

In both cases,
if v = 0:  Bcc dest      link address PC + 4 is not deposited
if v = 1:  Ccc dest      link address PC + 4 is deposited in R15

     code    cc   condition              flags
     ----------------------------------------------
     0000    MI   negative (minus)       N
     0001    EQ   equal (zero)           Z
     0010    CS   carry set (lower)      C
     0011    VS   overflow set           V
     0100    LS   lower or same          C|Z
     0101    LT   less than              N^V
     0110    LE   less or equal          (N^V)|Z
     0111         always                 true
     1000    PL   positive (plus)        ~N
     1001    NE   not equal (not zero)   ~Z
     1010    CC   carry clear            ~C
     1011    VC   overflow clear         ~V
     1100    HI   higher                 ~(C|Z)
     1101    GE   greater or equal       ~(N^V)
     1110    GT   greater than           ~((N^V)|Z)
     1111    NVR  never                  false


4. Interrupts
-------------

t.b.s.


5. Devices
----------

t.b.s.


References (in chronological order)
-----------------------------------

[1] Wirth, Niklaus
    Gutknecht, Juerg
    Project Oberon
    Revised Edition 2013
    Chapter 16, Implementation of the RISC processor
    File: wirth/PO.Computer.pdf

[2] Wirth, Niklaus
    The Design of a RISC Architecture and its Implementation with an FPGA
    Rev. 01.09.2015
    File: wirth/RISC.pdf

[3] Wirth, Niklaus
    An Update of the RISC5 Implementation
    15.06.2018
    File: wirth/RISC5.Update.pdf

[4] Wirth, Niklaus
    The RISC Architecture
    Rev. 09.08.2018
    File: wirth/RISC-Arch.pdf

